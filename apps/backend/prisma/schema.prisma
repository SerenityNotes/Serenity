datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
  output          = "./generated/output"
}

model Document {
  id                        String        @id
  activeSnapshot            Snapshot?     @relation(name: "activeSnapshot", fields: [activeSnapshotId], references: [id], onDelete: Cascade)
  activeSnapshotId          String?       @unique
  snapshots                 Snapshot[]
  createdAt                 DateTime      @default(now())
  workspace                 Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceKeyId            String?
  workspaceKey              WorkspaceKey? @relation(fields: [workspaceKeyId], references: [id], onDelete: SetNull)
  workspaceId               String
  parentFolder              Folder?       @relation(fields: [parentFolderId], references: [id], onDelete: Cascade)
  parentFolderId            String?
  encryptedName             String?
  encryptedNameNonce        String?
  subkeyId                  Int?
  contentSubkeyId           Int?
  nameKeyDerivationTrace    Json?
  contentKeyDerivationTrace Json?

  @@unique([subkeyId, workspaceId])
}

model Snapshot {
  id                     String    @id @default(uuid())
  latestVersion          Int
  data                   String
  preview                String // title & icon
  document               Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId             String
  updates                Update[]
  activeSnapshotDocument Document? @relation("activeSnapshot")
  createdAt              DateTime  @default(now())
  clocks                 Json
}

model Update {
  id              String   @id @default(uuid())
  version         Int
  data            String
  snapshot        Snapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  snapshotId      String
  snapshotVersion Int
  pubKey          String

  @@unique([snapshotId, version])
  @@unique([snapshotId, pubKey, snapshotVersion])
}

model UnverifiedUser {
  id                                         String    @id @default(uuid())
  username                                   String
  opaqueEnvelope                             String
  // contains the device signingPrivateKey and encryptionPrivateKey
  // can be decrypted using the key storred in the OPAQUE envelope
  passwordResetOneTimePassword               String?
  passwordResetOneTimePasswordExpireDateTime DateTime?
  confirmationCode                           String    @default(uuid())
  mainDeviceNonce                            String    @unique
  mainDeviceCiphertext                       String
  mainDeviceEncryptionKeySalt                String
  mainDeviceSigningPublicKey                 String    @unique
  mainDeviceEncryptionPublicKey              String    @unique
  mainDeviceEncryptionPublicKeySignature     String    @unique
  pendingWorkspaceInvitationId               String?
}

model User {
  id                                         String                 @id @default(uuid())
  username                                   String                 @unique
  opaqueEnvelope                             String
  // contains the device signingPrivateKey and encryptionPrivateKey
  // can be decrypted using the key storred in the OPAQUE envelope
  mainDeviceCiphertext                       String
  // nonce to decrypt the mainDeviceCiphertext
  mainDeviceNonce                            String                 @unique
  mainDeviceEncryptionKeySalt                String
  mainDevice                                 Device                 @relation(name: "mainDevice", fields: [mainDeviceSigningPublicKey], references: [signingPublicKey])
  mainDeviceSigningPublicKey                 String                 @unique
  devices                                    Device[]
  recoveryDevice                             RecoveryDevice?
  passwordResetOneTimePassword               String?
  passwordResetOneTimePasswordExpireDateTime DateTime?
  usersToWorkspaces                          UsersToWorkspaces[]
  workspaceInvitations                       WorkspaceInvitations[]
  sessions                                   Session[]
  pendingWorkspaceInvitationId               String?
  creatorDevices                             CreatorDevice[]
}

model Session {
  sessionKey             String   @id
  expiresAt              DateTime
  createdAt              DateTime @default(now())
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                 String
  device                 Device   @relation(fields: [deviceSigningPublicKey], references: [signingPublicKey], onDelete: Cascade)
  deviceSigningPublicKey String
}

model WorkspaceInvitations {
  id            String    @id @default(uuid())
  inviterUser   User      @relation(fields: [inviterUserId], references: [id], onDelete: Cascade)
  inviterUserId String
  workspace     Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId   String
  createdAt     DateTime  @default(now())
  expiresAt     DateTime
}

model RecoveryDevice {
  // contains the device signingPrivateKey and encryptionPrivateKey
  // can be decrypted using the key exposed to the user during recovery setup process
  ciphertext                                 String
  // nonce to decrypt the ciphertext
  nonce                                      String @unique
  device                                     Device @relation(fields: [deviceSigningPublicKey], references: [signingPublicKey])
  deviceSigningPublicKey                     String @id
  user                                       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                                     String @unique
  // this cross signing makes sure that the main device and recovery device are linked and verifyable in both directions
  // signed by the user's recovery device
  signatureForMainDeviceSigningPublicKey     String
  // signed by the user's main device
  signatureForRecoveryDeviceSigningPublicKey String
}

model Device {
  signingPublicKey             String          @id @unique
  encryptionPublicKey          String
  encryptionPublicKeySignature String
  // can't be mandatory since we need to create the device
  user                         User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                       String?
  recoveryDevice               RecoveryDevice?
  userForMain                  User?           @relation("mainDevice")
  info                         String?
  createdAt                    DateTime        @default(now())
  session                      Session[]
}

model CreatorDevice {
  signingPublicKey             String            @id @unique
  encryptionPublicKey          String
  encryptionPublicKeySignature String
  user                         User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId                       String?
  createdAt                    DateTime          @default(now())
  workspaceKeyBoxes            WorkspaceKeyBox[]
}

model Workspace {
  id                String                 @id
  idSignature       String
  name              String // TODO must be encrypted
  folders           Folder[]
  documents         Document[]
  usersToWorkspaces UsersToWorkspaces[]
  invitations       WorkspaceInvitations[]
  workspaceKey      WorkspaceKey[]
}

model UsersToWorkspaces {
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId             String
  workspace          Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId        String
  isAdmin            Boolean
  isAuthorizedMember Boolean   @default(false)

  @@id([userId, workspaceId])
}

model WorkspaceKey {
  id                String            @id @unique
  workspaceKeyBoxes WorkspaceKeyBox[]
  workspace         Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId       String
  generation        Int               @default(0)
  folders           Folder[]
  documents         Document[]
}

model WorkspaceKeyBox {
  id                            String        @id @unique @default(uuid())
  workspaceKey                  WorkspaceKey  @relation(fields: [workspaceKeyId], references: [id], onDelete: Cascade)
  workspaceKeyId                String
  deviceSigningPublicKey        String
  creatorDeviceSigningPublicKey String        @default("invalid")
  nonce                         String        @default("invalid")
  ciphertext                    String
  creatorDevice                 CreatorDevice @relation(fields: [creatorDeviceSigningPublicKey], references: [signingPublicKey], onDelete: SetDefault)
}

model Folder {
  id                 String        @id @unique
  idSignature        String
  encryptedName      String
  encryptedNameNonce String
  subkeyId           Int
  workspace          Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId        String
  workspaceKey       WorkspaceKey? @relation(fields: [workspaceKeyId], references: [id], onDelete: SetDefault)
  workspaceKeyId     String        @default("invalid")
  parentFolder       Folder?       @relation(name: "parentFolder", fields: [parentFolderId], references: [id], onDelete: Cascade)
  parentFolderId     String?
  keyDerivationTrace Json?
  rootFolder         Folder?       @relation(name: "rootFolder", fields: [rootFolderId], references: [id], onDelete: Cascade)
  rootFolderId       String?
  createdAt          DateTime      @default(now())
  childFolders       Folder[]      @relation("parentFolder")
  descendent         Folder[]      @relation("rootFolder")
  documents          Document[]

  @@unique([subkeyId, workspaceId])
}
