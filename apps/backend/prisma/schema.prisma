datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
  output          = "./generated/output"
}

model Document {
  id               String     @id
  activeSnapshot   Snapshot?  @relation(name: "activeSnapshot", fields: [activeSnapshotId], references: [id], onDelete: Cascade)
  activeSnapshotId String?    @unique
  snapshots        Snapshot[]
  createdAt        DateTime   @default(now())
  workspace        Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId      String
  parentFolder     Folder?    @relation(fields: [parentFolderId], references: [id], onDelete: Cascade)
  parentFolderId   String?
  name             String // TODO must be encrypted
}

model Snapshot {
  id                     String    @id @default(uuid())
  latestVersion          Int
  data                   String
  preview                String // title & icon
  document               Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId             String
  updates                Update[]
  activeSnapshotDocument Document? @relation("activeSnapshot")
  createdAt              DateTime  @default(now())
  clocks                 Json
}

model Update {
  id              String   @id @default(uuid())
  version         Int
  data            String
  snapshot        Snapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  snapshotId      String
  snapshotVersion Int
  pubKey          String

  @@unique([snapshotId, version])
  @@unique([snapshotId, pubKey, snapshotVersion])
}

model User {
  username                                   String              @id
  clientPublicKey                            String
  opaqueEnvelope                             String
  // contains the device signingPrivateKey and encryptionPrivateKey
  // can be decrypted using the key storred in the OPAQUE envelope
  masterDeviceCiphertext                     String
  // nonce to decrypt the masterDeviceCiphertext
  masterDeviceNonce                          String
  masterDevice                               Device              @relation(name: "masterDevice", fields: [masterDeviceSigningPublicKey], references: [signingPublicKey])
  masterDeviceSigningPublicKey               String              @unique
  devices                                    Device[]
  recoveryDevice                             RecoveryDevice?
  passwordResetOneTimePassword               String?
  passwordResetOneTimePasswordExpireDateTime DateTime?
  usersToWorkspaces                          UsersToWorkspaces[]
}

model RecoveryDevice {
  // contains the device signingPrivateKey and encryptionPrivateKey
  // can be decrypted using the key exposed to the user during recovery setup process
  ciphertext                                 String
  // nonce to decrypt the ciphertext
  nonce                                      String
  device                                     Device @relation(fields: [deviceSigningPublicKey], references: [signingPublicKey])
  deviceSigningPublicKey                     String @id
  user                                       User   @relation(fields: [userUsername], references: [username])
  userUsername                               String @unique
  // this cross signing makes sure that the master device and recovery device are linked and verifyable in both directions
  // signed by the user's recovery device
  signatureForMasterDeviceSigningPublicKey   String
  // signed by the user's master device
  signatureForRecoveryDeviceSigningPublicKey String

}

model Device {
  signingPublicKey             String          @id @unique
  encryptionPublicKey          String
  encryptionPublicKeySignature String
  // can't be mandatory since we need to create the device
  user                         User?           @relation(fields: [username], references: [username], onDelete: Cascade)
  username                     String?
  recoveryDevice               RecoveryDevice?
  userForMaster                User?           @relation("masterDevice")
}

model Workspace {
  id                String              @id
  idSignature       String
  name              String // TODO must be encrypted
  folders           Folder[]
  documents         Document[]
  usersToWorkspaces UsersToWorkspaces[]
}

model UsersToWorkspaces {
  user        User      @relation(fields: [username], references: [username], onDelete: Cascade)
  username    String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String
  isAdmin     Boolean

  @@id([username, workspaceId])
}

model Folder {
  id             String     @id
  idSignature    String
  name           String // TODO must be encrypted
  workspace      Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId    String
  parentFolder   Folder?    @relation(name: "parentFolder", fields: [parentFolderId], references: [id], onDelete: Cascade)
  parentFolderId String?
  rootFolder     Folder?    @relation(name: "rootFolder", fields: [rootFolderId], references: [id], onDelete: Cascade)
  rootFolderId   String?
  childFolders   Folder[]   @relation("parentFolder")
  descendent     Folder[]   @relation("rootFolder")
  documents      Document[]
}
